"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/workflows/[...slug]/page",{

/***/ "(app-pages-browser)/./src/features/workflows/hooks/workflows-extra/useStepEditor.ts":
/*!***********************************************************************!*\
  !*** ./src/features/workflows/hooks/workflows-extra/useStepEditor.ts ***!
  \***********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStepEditor: function() { return /* binding */ useStepEditor; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// Helper to compare step objects by key fields (ignoring step_order which changes frequently)\nfunction areStepsEqual(step1, step2) {\n    if (!step1 || !step2) return step1 === step2;\n    return step1.step_name === step2.step_name && step1.step_description === step2.step_description && step1.step_type === step2.step_type && step1.model === step2.model && step1.instructions === step2.instructions && step1.webhook_url === step2.webhook_url && JSON.stringify(step1.webhook_headers || {}) === JSON.stringify(step2.webhook_headers || {}) && JSON.stringify(step1.webhook_data_selection || {}) === JSON.stringify(step2.webhook_data_selection || {}) && JSON.stringify(step1.tools || []) === JSON.stringify(step2.tools || []) && step1.tool_choice === step2.tool_choice && JSON.stringify((step1.depends_on || []).sort()) === JSON.stringify((step2.depends_on || []).sort());\n}\nfunction useStepEditor(param) {\n    let { step, index, onChange } = param;\n    const [localStep, setLocalStep] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(step);\n    const [webhookHeaders, setWebhookHeaders] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(step.webhook_headers || {});\n    const lastSentStepRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isInternalUpdateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Sync localStep when step prop changes (only if values actually changed)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Skip update if this change came from our own handleChange\n        if (isInternalUpdateRef.current) {\n            isInternalUpdateRef.current = false;\n            // Track what we just sent\n            lastSentStepRef.current = step;\n            return;\n        }\n        // Check if this is the step we just sent (parent echoing back our change)\n        if (lastSentStepRef.current && areStepsEqual(step, lastSentStepRef.current)) {\n            // This is our own update being echoed back - ignore it\n            return;\n        }\n        // Only update if the step actually changed (not just a new object reference)\n        if (!areStepsEqual(step, localStep)) {\n            setLocalStep(step);\n            // Sync webhook headers\n            if (step.webhook_headers) {\n                setWebhookHeaders(step.webhook_headers);\n            } else {\n                setWebhookHeaders({});\n            }\n        }\n    }, [\n        step\n    ]) // Only depend on step, not localStep to avoid loops\n    ;\n    const handleChange = (field, value)=>{\n        isInternalUpdateRef.current = true;\n        const updated = {\n            ...localStep,\n            [field]: value\n        };\n        setLocalStep(updated);\n        lastSentStepRef.current = updated;\n        onChange(index, updated);\n    };\n    const handleWebhookHeadersChange = (headers)=>{\n        setWebhookHeaders(headers);\n        handleChange(\"webhook_headers\", headers);\n    };\n    return {\n        localStep,\n        webhookHeaders,\n        handleChange,\n        handleWebhookHeadersChange\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9mZWF0dXJlcy93b3JrZmxvd3MvaG9va3Mvd29ya2Zsb3dzLWV4dHJhL3VzZVN0ZXBFZGl0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1EO0FBU25ELDhGQUE4RjtBQUM5RixTQUFTRyxjQUFjQyxLQUFtQixFQUFFQyxLQUFtQjtJQUM3RCxJQUFJLENBQUNELFNBQVMsQ0FBQ0MsT0FBTyxPQUFPRCxVQUFVQztJQUV2QyxPQUNFRCxNQUFNRSxTQUFTLEtBQUtELE1BQU1DLFNBQVMsSUFDbkNGLE1BQU1HLGdCQUFnQixLQUFLRixNQUFNRSxnQkFBZ0IsSUFDakRILE1BQU1JLFNBQVMsS0FBS0gsTUFBTUcsU0FBUyxJQUNuQ0osTUFBTUssS0FBSyxLQUFLSixNQUFNSSxLQUFLLElBQzNCTCxNQUFNTSxZQUFZLEtBQUtMLE1BQU1LLFlBQVksSUFDekNOLE1BQU1PLFdBQVcsS0FBS04sTUFBTU0sV0FBVyxJQUN2Q0MsS0FBS0MsU0FBUyxDQUFDVCxNQUFNVSxlQUFlLElBQUksQ0FBQyxPQUFPRixLQUFLQyxTQUFTLENBQUNSLE1BQU1TLGVBQWUsSUFBSSxDQUFDLE1BQ3pGRixLQUFLQyxTQUFTLENBQUNULE1BQU1XLHNCQUFzQixJQUFJLENBQUMsT0FBT0gsS0FBS0MsU0FBUyxDQUFDUixNQUFNVSxzQkFBc0IsSUFBSSxDQUFDLE1BQ3ZHSCxLQUFLQyxTQUFTLENBQUNULE1BQU1ZLEtBQUssSUFBSSxFQUFFLE1BQU1KLEtBQUtDLFNBQVMsQ0FBQ1IsTUFBTVcsS0FBSyxJQUFJLEVBQUUsS0FDdEVaLE1BQU1hLFdBQVcsS0FBS1osTUFBTVksV0FBVyxJQUN2Q0wsS0FBS0MsU0FBUyxDQUFDLENBQUNULE1BQU1jLFVBQVUsSUFBSSxFQUFFLEVBQUVDLElBQUksUUFBUVAsS0FBS0MsU0FBUyxDQUFDLENBQUNSLE1BQU1hLFVBQVUsSUFBSSxFQUFFLEVBQUVDLElBQUk7QUFHcEc7QUFFTyxTQUFTQyxjQUFjLEtBQTZDO1FBQTdDLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxRQUFRLEVBQXNCLEdBQTdDO0lBQzVCLE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHekIsK0NBQVFBLENBQWVxQjtJQUN6RCxNQUFNLENBQUNLLGdCQUFnQkMsa0JBQWtCLEdBQUczQiwrQ0FBUUEsQ0FDbERxQixLQUFLUCxlQUFlLElBQUksQ0FBQztJQUUzQixNQUFNYyxrQkFBa0IxQiw2Q0FBTUEsQ0FBc0I7SUFDcEQsTUFBTTJCLHNCQUFzQjNCLDZDQUFNQSxDQUFDO0lBRW5DLDBFQUEwRTtJQUMxRUQsZ0RBQVNBLENBQUM7UUFDUiw0REFBNEQ7UUFDNUQsSUFBSTRCLG9CQUFvQkMsT0FBTyxFQUFFO1lBQy9CRCxvQkFBb0JDLE9BQU8sR0FBRztZQUM5QiwwQkFBMEI7WUFDMUJGLGdCQUFnQkUsT0FBTyxHQUFHVDtZQUMxQjtRQUNGO1FBRUEsMEVBQTBFO1FBQzFFLElBQUlPLGdCQUFnQkUsT0FBTyxJQUFJM0IsY0FBY2tCLE1BQU1PLGdCQUFnQkUsT0FBTyxHQUFHO1lBQzNFLHVEQUF1RDtZQUN2RDtRQUNGO1FBRUEsNkVBQTZFO1FBQzdFLElBQUksQ0FBQzNCLGNBQWNrQixNQUFNRyxZQUFZO1lBQ25DQyxhQUFhSjtZQUNiLHVCQUF1QjtZQUN2QixJQUFJQSxLQUFLUCxlQUFlLEVBQUU7Z0JBQ3hCYSxrQkFBa0JOLEtBQUtQLGVBQWU7WUFDeEMsT0FBTztnQkFDTGEsa0JBQWtCLENBQUM7WUFDckI7UUFDRjtJQUNGLEdBQUc7UUFBQ047S0FBSyxFQUFFLG9EQUFvRDs7SUFFL0QsTUFBTVUsZUFBZSxDQUFDQyxPQUEyQkM7UUFDL0NKLG9CQUFvQkMsT0FBTyxHQUFHO1FBQzlCLE1BQU1JLFVBQVU7WUFBRSxHQUFHVixTQUFTO1lBQUUsQ0FBQ1EsTUFBTSxFQUFFQztRQUFNO1FBQy9DUixhQUFhUztRQUNiTixnQkFBZ0JFLE9BQU8sR0FBR0k7UUFDMUJYLFNBQVNELE9BQU9ZO0lBQ2xCO0lBRUEsTUFBTUMsNkJBQTZCLENBQUNDO1FBQ2xDVCxrQkFBa0JTO1FBQ2xCTCxhQUFhLG1CQUFtQks7SUFDbEM7SUFFQSxPQUFPO1FBQ0xaO1FBQ0FFO1FBQ0FLO1FBQ0FJO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZmVhdHVyZXMvd29ya2Zsb3dzL2hvb2tzL3dvcmtmbG93cy1leHRyYS91c2VTdGVwRWRpdG9yLnRzPzNhM2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBXb3JrZmxvd1N0ZXAgfSBmcm9tICdAL2ZlYXR1cmVzL3dvcmtmbG93cy90eXBlcydcblxuaW50ZXJmYWNlIFVzZVN0ZXBFZGl0b3JQcm9wcyB7XG4gIHN0ZXA6IFdvcmtmbG93U3RlcFxuICBpbmRleDogbnVtYmVyXG4gIG9uQ2hhbmdlOiAoaW5kZXg6IG51bWJlciwgc3RlcDogV29ya2Zsb3dTdGVwKSA9PiB2b2lkXG59XG5cbi8vIEhlbHBlciB0byBjb21wYXJlIHN0ZXAgb2JqZWN0cyBieSBrZXkgZmllbGRzIChpZ25vcmluZyBzdGVwX29yZGVyIHdoaWNoIGNoYW5nZXMgZnJlcXVlbnRseSlcbmZ1bmN0aW9uIGFyZVN0ZXBzRXF1YWwoc3RlcDE6IFdvcmtmbG93U3RlcCwgc3RlcDI6IFdvcmtmbG93U3RlcCk6IGJvb2xlYW4ge1xuICBpZiAoIXN0ZXAxIHx8ICFzdGVwMikgcmV0dXJuIHN0ZXAxID09PSBzdGVwMlxuICBcbiAgcmV0dXJuIChcbiAgICBzdGVwMS5zdGVwX25hbWUgPT09IHN0ZXAyLnN0ZXBfbmFtZSAmJlxuICAgIHN0ZXAxLnN0ZXBfZGVzY3JpcHRpb24gPT09IHN0ZXAyLnN0ZXBfZGVzY3JpcHRpb24gJiZcbiAgICBzdGVwMS5zdGVwX3R5cGUgPT09IHN0ZXAyLnN0ZXBfdHlwZSAmJlxuICAgIHN0ZXAxLm1vZGVsID09PSBzdGVwMi5tb2RlbCAmJlxuICAgIHN0ZXAxLmluc3RydWN0aW9ucyA9PT0gc3RlcDIuaW5zdHJ1Y3Rpb25zICYmXG4gICAgc3RlcDEud2ViaG9va191cmwgPT09IHN0ZXAyLndlYmhvb2tfdXJsICYmXG4gICAgSlNPTi5zdHJpbmdpZnkoc3RlcDEud2ViaG9va19oZWFkZXJzIHx8IHt9KSA9PT0gSlNPTi5zdHJpbmdpZnkoc3RlcDIud2ViaG9va19oZWFkZXJzIHx8IHt9KSAmJlxuICAgIEpTT04uc3RyaW5naWZ5KHN0ZXAxLndlYmhvb2tfZGF0YV9zZWxlY3Rpb24gfHwge30pID09PSBKU09OLnN0cmluZ2lmeShzdGVwMi53ZWJob29rX2RhdGFfc2VsZWN0aW9uIHx8IHt9KSAmJlxuICAgIEpTT04uc3RyaW5naWZ5KHN0ZXAxLnRvb2xzIHx8IFtdKSA9PT0gSlNPTi5zdHJpbmdpZnkoc3RlcDIudG9vbHMgfHwgW10pICYmXG4gICAgc3RlcDEudG9vbF9jaG9pY2UgPT09IHN0ZXAyLnRvb2xfY2hvaWNlICYmXG4gICAgSlNPTi5zdHJpbmdpZnkoKHN0ZXAxLmRlcGVuZHNfb24gfHwgW10pLnNvcnQoKSkgPT09IEpTT04uc3RyaW5naWZ5KChzdGVwMi5kZXBlbmRzX29uIHx8IFtdKS5zb3J0KCkpXG4gICAgLy8gTm90ZTogc3RlcF9vcmRlciBpcyBpbnRlbnRpb25hbGx5IGV4Y2x1ZGVkIGFzIGl0IGNoYW5nZXMgZnJlcXVlbnRseVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGVwRWRpdG9yKHsgc3RlcCwgaW5kZXgsIG9uQ2hhbmdlIH06IFVzZVN0ZXBFZGl0b3JQcm9wcykge1xuICBjb25zdCBbbG9jYWxTdGVwLCBzZXRMb2NhbFN0ZXBdID0gdXNlU3RhdGU8V29ya2Zsb3dTdGVwPihzdGVwKVxuICBjb25zdCBbd2ViaG9va0hlYWRlcnMsIHNldFdlYmhvb2tIZWFkZXJzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+KFxuICAgIHN0ZXAud2ViaG9va19oZWFkZXJzIHx8IHt9XG4gIClcbiAgY29uc3QgbGFzdFNlbnRTdGVwUmVmID0gdXNlUmVmPFdvcmtmbG93U3RlcCB8IG51bGw+KG51bGwpXG4gIGNvbnN0IGlzSW50ZXJuYWxVcGRhdGVSZWYgPSB1c2VSZWYoZmFsc2UpXG5cbiAgLy8gU3luYyBsb2NhbFN0ZXAgd2hlbiBzdGVwIHByb3AgY2hhbmdlcyAob25seSBpZiB2YWx1ZXMgYWN0dWFsbHkgY2hhbmdlZClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTa2lwIHVwZGF0ZSBpZiB0aGlzIGNoYW5nZSBjYW1lIGZyb20gb3VyIG93biBoYW5kbGVDaGFuZ2VcbiAgICBpZiAoaXNJbnRlcm5hbFVwZGF0ZVJlZi5jdXJyZW50KSB7XG4gICAgICBpc0ludGVybmFsVXBkYXRlUmVmLmN1cnJlbnQgPSBmYWxzZVxuICAgICAgLy8gVHJhY2sgd2hhdCB3ZSBqdXN0IHNlbnRcbiAgICAgIGxhc3RTZW50U3RlcFJlZi5jdXJyZW50ID0gc3RlcFxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIHN0ZXAgd2UganVzdCBzZW50IChwYXJlbnQgZWNob2luZyBiYWNrIG91ciBjaGFuZ2UpXG4gICAgaWYgKGxhc3RTZW50U3RlcFJlZi5jdXJyZW50ICYmIGFyZVN0ZXBzRXF1YWwoc3RlcCwgbGFzdFNlbnRTdGVwUmVmLmN1cnJlbnQpKSB7XG4gICAgICAvLyBUaGlzIGlzIG91ciBvd24gdXBkYXRlIGJlaW5nIGVjaG9lZCBiYWNrIC0gaWdub3JlIGl0XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgXG4gICAgLy8gT25seSB1cGRhdGUgaWYgdGhlIHN0ZXAgYWN0dWFsbHkgY2hhbmdlZCAobm90IGp1c3QgYSBuZXcgb2JqZWN0IHJlZmVyZW5jZSlcbiAgICBpZiAoIWFyZVN0ZXBzRXF1YWwoc3RlcCwgbG9jYWxTdGVwKSkge1xuICAgICAgc2V0TG9jYWxTdGVwKHN0ZXApXG4gICAgICAvLyBTeW5jIHdlYmhvb2sgaGVhZGVyc1xuICAgICAgaWYgKHN0ZXAud2ViaG9va19oZWFkZXJzKSB7XG4gICAgICAgIHNldFdlYmhvb2tIZWFkZXJzKHN0ZXAud2ViaG9va19oZWFkZXJzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0V2ViaG9va0hlYWRlcnMoe30pXG4gICAgICB9XG4gICAgfVxuICB9LCBbc3RlcF0pIC8vIE9ubHkgZGVwZW5kIG9uIHN0ZXAsIG5vdCBsb2NhbFN0ZXAgdG8gYXZvaWQgbG9vcHNcblxuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSAoZmllbGQ6IGtleW9mIFdvcmtmbG93U3RlcCwgdmFsdWU6IGFueSkgPT4ge1xuICAgIGlzSW50ZXJuYWxVcGRhdGVSZWYuY3VycmVudCA9IHRydWVcbiAgICBjb25zdCB1cGRhdGVkID0geyAuLi5sb2NhbFN0ZXAsIFtmaWVsZF06IHZhbHVlIH1cbiAgICBzZXRMb2NhbFN0ZXAodXBkYXRlZClcbiAgICBsYXN0U2VudFN0ZXBSZWYuY3VycmVudCA9IHVwZGF0ZWRcbiAgICBvbkNoYW5nZShpbmRleCwgdXBkYXRlZClcbiAgfVxuXG4gIGNvbnN0IGhhbmRsZVdlYmhvb2tIZWFkZXJzQ2hhbmdlID0gKGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pID0+IHtcbiAgICBzZXRXZWJob29rSGVhZGVycyhoZWFkZXJzKVxuICAgIGhhbmRsZUNoYW5nZSgnd2ViaG9va19oZWFkZXJzJywgaGVhZGVycylcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbG9jYWxTdGVwLFxuICAgIHdlYmhvb2tIZWFkZXJzLFxuICAgIGhhbmRsZUNoYW5nZSxcbiAgICBoYW5kbGVXZWJob29rSGVhZGVyc0NoYW5nZSxcbiAgfVxufVxuXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJhcmVTdGVwc0VxdWFsIiwic3RlcDEiLCJzdGVwMiIsInN0ZXBfbmFtZSIsInN0ZXBfZGVzY3JpcHRpb24iLCJzdGVwX3R5cGUiLCJtb2RlbCIsImluc3RydWN0aW9ucyIsIndlYmhvb2tfdXJsIiwiSlNPTiIsInN0cmluZ2lmeSIsIndlYmhvb2tfaGVhZGVycyIsIndlYmhvb2tfZGF0YV9zZWxlY3Rpb24iLCJ0b29scyIsInRvb2xfY2hvaWNlIiwiZGVwZW5kc19vbiIsInNvcnQiLCJ1c2VTdGVwRWRpdG9yIiwic3RlcCIsImluZGV4Iiwib25DaGFuZ2UiLCJsb2NhbFN0ZXAiLCJzZXRMb2NhbFN0ZXAiLCJ3ZWJob29rSGVhZGVycyIsInNldFdlYmhvb2tIZWFkZXJzIiwibGFzdFNlbnRTdGVwUmVmIiwiaXNJbnRlcm5hbFVwZGF0ZVJlZiIsImN1cnJlbnQiLCJoYW5kbGVDaGFuZ2UiLCJmaWVsZCIsInZhbHVlIiwidXBkYXRlZCIsImhhbmRsZVdlYmhvb2tIZWFkZXJzQ2hhbmdlIiwiaGVhZGVycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/features/workflows/hooks/workflows-extra/useStepEditor.ts\n"));

/***/ })

});