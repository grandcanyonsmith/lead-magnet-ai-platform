"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/workflows/new/page",{

/***/ "(app-pages-browser)/./src/features/workflows/hooks/workflows-extra/useStepEditor.ts":
/*!***********************************************************************!*\
  !*** ./src/features/workflows/hooks/workflows-extra/useStepEditor.ts ***!
  \***********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStepEditor: function() { return /* binding */ useStepEditor; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// Helper to compare step objects by key fields (ignoring step_order which changes frequently)\nfunction areStepsEqual(step1, step2) {\n    if (!step1 || !step2) return step1 === step2;\n    return step1.step_name === step2.step_name && step1.step_description === step2.step_description && step1.step_type === step2.step_type && step1.model === step2.model && step1.instructions === step2.instructions && step1.webhook_url === step2.webhook_url && JSON.stringify(step1.webhook_headers || {}) === JSON.stringify(step2.webhook_headers || {}) && JSON.stringify(step1.webhook_data_selection || {}) === JSON.stringify(step2.webhook_data_selection || {}) && JSON.stringify(step1.tools || []) === JSON.stringify(step2.tools || []) && step1.tool_choice === step2.tool_choice && JSON.stringify((step1.depends_on || []).sort()) === JSON.stringify((step2.depends_on || []).sort());\n}\nfunction useStepEditor(param) {\n    let { step, index, onChange } = param;\n    const [localStep, setLocalStep] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(step);\n    const [webhookHeaders, setWebhookHeaders] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(step.webhook_headers || {});\n    const lastSentStepRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isInternalUpdateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const localStepRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(step);\n    // Keep ref in sync with state\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        localStepRef.current = localStep;\n    }, [\n        localStep\n    ]);\n    // Sync localStep when step prop changes (only if values actually changed)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Skip update if this change came from our own handleChange\n        if (isInternalUpdateRef.current) {\n            isInternalUpdateRef.current = false;\n            // Track what we just sent\n            lastSentStepRef.current = step;\n            return;\n        }\n        // Check if this is the step we just sent (parent echoing back our change)\n        if (lastSentStepRef.current && areStepsEqual(step, lastSentStepRef.current)) {\n            // This is our own update being echoed back - ignore it\n            return;\n        }\n        // Only update if the step actually changed (not just a new object reference)\n        // Use ref to get current localStep value without adding to dependencies\n        if (!areStepsEqual(step, localStepRef.current)) {\n            setLocalStep(step);\n            localStepRef.current = step;\n            // Sync webhook headers\n            if (step.webhook_headers) {\n                setWebhookHeaders(step.webhook_headers);\n            } else {\n                setWebhookHeaders({});\n            }\n        }\n    }, [\n        step\n    ]) // Only depend on step, not localStep to avoid loops\n    ;\n    const handleChange = (field, value)=>{\n        isInternalUpdateRef.current = true;\n        const updated = {\n            ...localStep,\n            [field]: value\n        };\n        setLocalStep(updated);\n        localStepRef.current = updated;\n        lastSentStepRef.current = updated;\n        onChange(index, updated);\n    };\n    const handleWebhookHeadersChange = (headers)=>{\n        setWebhookHeaders(headers);\n        handleChange(\"webhook_headers\", headers);\n    };\n    return {\n        localStep,\n        webhookHeaders,\n        handleChange,\n        handleWebhookHeadersChange\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9mZWF0dXJlcy93b3JrZmxvd3MvaG9va3Mvd29ya2Zsb3dzLWV4dHJhL3VzZVN0ZXBFZGl0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1EO0FBU25ELDhGQUE4RjtBQUM5RixTQUFTRyxjQUFjQyxLQUFtQixFQUFFQyxLQUFtQjtJQUM3RCxJQUFJLENBQUNELFNBQVMsQ0FBQ0MsT0FBTyxPQUFPRCxVQUFVQztJQUV2QyxPQUNFRCxNQUFNRSxTQUFTLEtBQUtELE1BQU1DLFNBQVMsSUFDbkNGLE1BQU1HLGdCQUFnQixLQUFLRixNQUFNRSxnQkFBZ0IsSUFDakRILE1BQU1JLFNBQVMsS0FBS0gsTUFBTUcsU0FBUyxJQUNuQ0osTUFBTUssS0FBSyxLQUFLSixNQUFNSSxLQUFLLElBQzNCTCxNQUFNTSxZQUFZLEtBQUtMLE1BQU1LLFlBQVksSUFDekNOLE1BQU1PLFdBQVcsS0FBS04sTUFBTU0sV0FBVyxJQUN2Q0MsS0FBS0MsU0FBUyxDQUFDVCxNQUFNVSxlQUFlLElBQUksQ0FBQyxPQUFPRixLQUFLQyxTQUFTLENBQUNSLE1BQU1TLGVBQWUsSUFBSSxDQUFDLE1BQ3pGRixLQUFLQyxTQUFTLENBQUNULE1BQU1XLHNCQUFzQixJQUFJLENBQUMsT0FBT0gsS0FBS0MsU0FBUyxDQUFDUixNQUFNVSxzQkFBc0IsSUFBSSxDQUFDLE1BQ3ZHSCxLQUFLQyxTQUFTLENBQUNULE1BQU1ZLEtBQUssSUFBSSxFQUFFLE1BQU1KLEtBQUtDLFNBQVMsQ0FBQ1IsTUFBTVcsS0FBSyxJQUFJLEVBQUUsS0FDdEVaLE1BQU1hLFdBQVcsS0FBS1osTUFBTVksV0FBVyxJQUN2Q0wsS0FBS0MsU0FBUyxDQUFDLENBQUNULE1BQU1jLFVBQVUsSUFBSSxFQUFFLEVBQUVDLElBQUksUUFBUVAsS0FBS0MsU0FBUyxDQUFDLENBQUNSLE1BQU1hLFVBQVUsSUFBSSxFQUFFLEVBQUVDLElBQUk7QUFHcEc7QUFFTyxTQUFTQyxjQUFjLEtBQTZDO1FBQTdDLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxRQUFRLEVBQXNCLEdBQTdDO0lBQzVCLE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHekIsK0NBQVFBLENBQWVxQjtJQUN6RCxNQUFNLENBQUNLLGdCQUFnQkMsa0JBQWtCLEdBQUczQiwrQ0FBUUEsQ0FDbERxQixLQUFLUCxlQUFlLElBQUksQ0FBQztJQUUzQixNQUFNYyxrQkFBa0IxQiw2Q0FBTUEsQ0FBc0I7SUFDcEQsTUFBTTJCLHNCQUFzQjNCLDZDQUFNQSxDQUFDO0lBQ25DLE1BQU00QixlQUFlNUIsNkNBQU1BLENBQWVtQjtJQUUxQyw4QkFBOEI7SUFDOUJwQixnREFBU0EsQ0FBQztRQUNSNkIsYUFBYUMsT0FBTyxHQUFHUDtJQUN6QixHQUFHO1FBQUNBO0tBQVU7SUFFZCwwRUFBMEU7SUFDMUV2QixnREFBU0EsQ0FBQztRQUNSLDREQUE0RDtRQUM1RCxJQUFJNEIsb0JBQW9CRSxPQUFPLEVBQUU7WUFDL0JGLG9CQUFvQkUsT0FBTyxHQUFHO1lBQzlCLDBCQUEwQjtZQUMxQkgsZ0JBQWdCRyxPQUFPLEdBQUdWO1lBQzFCO1FBQ0Y7UUFFQSwwRUFBMEU7UUFDMUUsSUFBSU8sZ0JBQWdCRyxPQUFPLElBQUk1QixjQUFja0IsTUFBTU8sZ0JBQWdCRyxPQUFPLEdBQUc7WUFDM0UsdURBQXVEO1lBQ3ZEO1FBQ0Y7UUFFQSw2RUFBNkU7UUFDN0Usd0VBQXdFO1FBQ3hFLElBQUksQ0FBQzVCLGNBQWNrQixNQUFNUyxhQUFhQyxPQUFPLEdBQUc7WUFDOUNOLGFBQWFKO1lBQ2JTLGFBQWFDLE9BQU8sR0FBR1Y7WUFDdkIsdUJBQXVCO1lBQ3ZCLElBQUlBLEtBQUtQLGVBQWUsRUFBRTtnQkFDeEJhLGtCQUFrQk4sS0FBS1AsZUFBZTtZQUN4QyxPQUFPO2dCQUNMYSxrQkFBa0IsQ0FBQztZQUNyQjtRQUNGO0lBQ0YsR0FBRztRQUFDTjtLQUFLLEVBQUUsb0RBQW9EOztJQUUvRCxNQUFNVyxlQUFlLENBQUNDLE9BQTJCQztRQUMvQ0wsb0JBQW9CRSxPQUFPLEdBQUc7UUFDOUIsTUFBTUksVUFBVTtZQUFFLEdBQUdYLFNBQVM7WUFBRSxDQUFDUyxNQUFNLEVBQUVDO1FBQU07UUFDL0NULGFBQWFVO1FBQ2JMLGFBQWFDLE9BQU8sR0FBR0k7UUFDdkJQLGdCQUFnQkcsT0FBTyxHQUFHSTtRQUMxQlosU0FBU0QsT0FBT2E7SUFDbEI7SUFFQSxNQUFNQyw2QkFBNkIsQ0FBQ0M7UUFDbENWLGtCQUFrQlU7UUFDbEJMLGFBQWEsbUJBQW1CSztJQUNsQztJQUVBLE9BQU87UUFDTGI7UUFDQUU7UUFDQU07UUFDQUk7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9mZWF0dXJlcy93b3JrZmxvd3MvaG9va3Mvd29ya2Zsb3dzLWV4dHJhL3VzZVN0ZXBFZGl0b3IudHM/M2EzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFdvcmtmbG93U3RlcCB9IGZyb20gJ0AvZmVhdHVyZXMvd29ya2Zsb3dzL3R5cGVzJ1xuXG5pbnRlcmZhY2UgVXNlU3RlcEVkaXRvclByb3BzIHtcbiAgc3RlcDogV29ya2Zsb3dTdGVwXG4gIGluZGV4OiBudW1iZXJcbiAgb25DaGFuZ2U6IChpbmRleDogbnVtYmVyLCBzdGVwOiBXb3JrZmxvd1N0ZXApID0+IHZvaWRcbn1cblxuLy8gSGVscGVyIHRvIGNvbXBhcmUgc3RlcCBvYmplY3RzIGJ5IGtleSBmaWVsZHMgKGlnbm9yaW5nIHN0ZXBfb3JkZXIgd2hpY2ggY2hhbmdlcyBmcmVxdWVudGx5KVxuZnVuY3Rpb24gYXJlU3RlcHNFcXVhbChzdGVwMTogV29ya2Zsb3dTdGVwLCBzdGVwMjogV29ya2Zsb3dTdGVwKTogYm9vbGVhbiB7XG4gIGlmICghc3RlcDEgfHwgIXN0ZXAyKSByZXR1cm4gc3RlcDEgPT09IHN0ZXAyXG4gIFxuICByZXR1cm4gKFxuICAgIHN0ZXAxLnN0ZXBfbmFtZSA9PT0gc3RlcDIuc3RlcF9uYW1lICYmXG4gICAgc3RlcDEuc3RlcF9kZXNjcmlwdGlvbiA9PT0gc3RlcDIuc3RlcF9kZXNjcmlwdGlvbiAmJlxuICAgIHN0ZXAxLnN0ZXBfdHlwZSA9PT0gc3RlcDIuc3RlcF90eXBlICYmXG4gICAgc3RlcDEubW9kZWwgPT09IHN0ZXAyLm1vZGVsICYmXG4gICAgc3RlcDEuaW5zdHJ1Y3Rpb25zID09PSBzdGVwMi5pbnN0cnVjdGlvbnMgJiZcbiAgICBzdGVwMS53ZWJob29rX3VybCA9PT0gc3RlcDIud2ViaG9va191cmwgJiZcbiAgICBKU09OLnN0cmluZ2lmeShzdGVwMS53ZWJob29rX2hlYWRlcnMgfHwge30pID09PSBKU09OLnN0cmluZ2lmeShzdGVwMi53ZWJob29rX2hlYWRlcnMgfHwge30pICYmXG4gICAgSlNPTi5zdHJpbmdpZnkoc3RlcDEud2ViaG9va19kYXRhX3NlbGVjdGlvbiB8fCB7fSkgPT09IEpTT04uc3RyaW5naWZ5KHN0ZXAyLndlYmhvb2tfZGF0YV9zZWxlY3Rpb24gfHwge30pICYmXG4gICAgSlNPTi5zdHJpbmdpZnkoc3RlcDEudG9vbHMgfHwgW10pID09PSBKU09OLnN0cmluZ2lmeShzdGVwMi50b29scyB8fCBbXSkgJiZcbiAgICBzdGVwMS50b29sX2Nob2ljZSA9PT0gc3RlcDIudG9vbF9jaG9pY2UgJiZcbiAgICBKU09OLnN0cmluZ2lmeSgoc3RlcDEuZGVwZW5kc19vbiB8fCBbXSkuc29ydCgpKSA9PT0gSlNPTi5zdHJpbmdpZnkoKHN0ZXAyLmRlcGVuZHNfb24gfHwgW10pLnNvcnQoKSlcbiAgICAvLyBOb3RlOiBzdGVwX29yZGVyIGlzIGludGVudGlvbmFsbHkgZXhjbHVkZWQgYXMgaXQgY2hhbmdlcyBmcmVxdWVudGx5XG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0ZXBFZGl0b3IoeyBzdGVwLCBpbmRleCwgb25DaGFuZ2UgfTogVXNlU3RlcEVkaXRvclByb3BzKSB7XG4gIGNvbnN0IFtsb2NhbFN0ZXAsIHNldExvY2FsU3RlcF0gPSB1c2VTdGF0ZTxXb3JrZmxvd1N0ZXA+KHN0ZXApXG4gIGNvbnN0IFt3ZWJob29rSGVhZGVycywgc2V0V2ViaG9va0hlYWRlcnNdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4oXG4gICAgc3RlcC53ZWJob29rX2hlYWRlcnMgfHwge31cbiAgKVxuICBjb25zdCBsYXN0U2VudFN0ZXBSZWYgPSB1c2VSZWY8V29ya2Zsb3dTdGVwIHwgbnVsbD4obnVsbClcbiAgY29uc3QgaXNJbnRlcm5hbFVwZGF0ZVJlZiA9IHVzZVJlZihmYWxzZSlcbiAgY29uc3QgbG9jYWxTdGVwUmVmID0gdXNlUmVmPFdvcmtmbG93U3RlcD4oc3RlcClcblxuICAvLyBLZWVwIHJlZiBpbiBzeW5jIHdpdGggc3RhdGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsb2NhbFN0ZXBSZWYuY3VycmVudCA9IGxvY2FsU3RlcFxuICB9LCBbbG9jYWxTdGVwXSlcblxuICAvLyBTeW5jIGxvY2FsU3RlcCB3aGVuIHN0ZXAgcHJvcCBjaGFuZ2VzIChvbmx5IGlmIHZhbHVlcyBhY3R1YWxseSBjaGFuZ2VkKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFNraXAgdXBkYXRlIGlmIHRoaXMgY2hhbmdlIGNhbWUgZnJvbSBvdXIgb3duIGhhbmRsZUNoYW5nZVxuICAgIGlmIChpc0ludGVybmFsVXBkYXRlUmVmLmN1cnJlbnQpIHtcbiAgICAgIGlzSW50ZXJuYWxVcGRhdGVSZWYuY3VycmVudCA9IGZhbHNlXG4gICAgICAvLyBUcmFjayB3aGF0IHdlIGp1c3Qgc2VudFxuICAgICAgbGFzdFNlbnRTdGVwUmVmLmN1cnJlbnQgPSBzdGVwXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgc3RlcCB3ZSBqdXN0IHNlbnQgKHBhcmVudCBlY2hvaW5nIGJhY2sgb3VyIGNoYW5nZSlcbiAgICBpZiAobGFzdFNlbnRTdGVwUmVmLmN1cnJlbnQgJiYgYXJlU3RlcHNFcXVhbChzdGVwLCBsYXN0U2VudFN0ZXBSZWYuY3VycmVudCkpIHtcbiAgICAgIC8vIFRoaXMgaXMgb3VyIG93biB1cGRhdGUgYmVpbmcgZWNob2VkIGJhY2sgLSBpZ25vcmUgaXRcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBcbiAgICAvLyBPbmx5IHVwZGF0ZSBpZiB0aGUgc3RlcCBhY3R1YWxseSBjaGFuZ2VkIChub3QganVzdCBhIG5ldyBvYmplY3QgcmVmZXJlbmNlKVxuICAgIC8vIFVzZSByZWYgdG8gZ2V0IGN1cnJlbnQgbG9jYWxTdGVwIHZhbHVlIHdpdGhvdXQgYWRkaW5nIHRvIGRlcGVuZGVuY2llc1xuICAgIGlmICghYXJlU3RlcHNFcXVhbChzdGVwLCBsb2NhbFN0ZXBSZWYuY3VycmVudCkpIHtcbiAgICAgIHNldExvY2FsU3RlcChzdGVwKVxuICAgICAgbG9jYWxTdGVwUmVmLmN1cnJlbnQgPSBzdGVwXG4gICAgICAvLyBTeW5jIHdlYmhvb2sgaGVhZGVyc1xuICAgICAgaWYgKHN0ZXAud2ViaG9va19oZWFkZXJzKSB7XG4gICAgICAgIHNldFdlYmhvb2tIZWFkZXJzKHN0ZXAud2ViaG9va19oZWFkZXJzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0V2ViaG9va0hlYWRlcnMoe30pXG4gICAgICB9XG4gICAgfVxuICB9LCBbc3RlcF0pIC8vIE9ubHkgZGVwZW5kIG9uIHN0ZXAsIG5vdCBsb2NhbFN0ZXAgdG8gYXZvaWQgbG9vcHNcblxuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSAoZmllbGQ6IGtleW9mIFdvcmtmbG93U3RlcCwgdmFsdWU6IGFueSkgPT4ge1xuICAgIGlzSW50ZXJuYWxVcGRhdGVSZWYuY3VycmVudCA9IHRydWVcbiAgICBjb25zdCB1cGRhdGVkID0geyAuLi5sb2NhbFN0ZXAsIFtmaWVsZF06IHZhbHVlIH1cbiAgICBzZXRMb2NhbFN0ZXAodXBkYXRlZClcbiAgICBsb2NhbFN0ZXBSZWYuY3VycmVudCA9IHVwZGF0ZWRcbiAgICBsYXN0U2VudFN0ZXBSZWYuY3VycmVudCA9IHVwZGF0ZWRcbiAgICBvbkNoYW5nZShpbmRleCwgdXBkYXRlZClcbiAgfVxuXG4gIGNvbnN0IGhhbmRsZVdlYmhvb2tIZWFkZXJzQ2hhbmdlID0gKGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pID0+IHtcbiAgICBzZXRXZWJob29rSGVhZGVycyhoZWFkZXJzKVxuICAgIGhhbmRsZUNoYW5nZSgnd2ViaG9va19oZWFkZXJzJywgaGVhZGVycylcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbG9jYWxTdGVwLFxuICAgIHdlYmhvb2tIZWFkZXJzLFxuICAgIGhhbmRsZUNoYW5nZSxcbiAgICBoYW5kbGVXZWJob29rSGVhZGVyc0NoYW5nZSxcbiAgfVxufVxuXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJhcmVTdGVwc0VxdWFsIiwic3RlcDEiLCJzdGVwMiIsInN0ZXBfbmFtZSIsInN0ZXBfZGVzY3JpcHRpb24iLCJzdGVwX3R5cGUiLCJtb2RlbCIsImluc3RydWN0aW9ucyIsIndlYmhvb2tfdXJsIiwiSlNPTiIsInN0cmluZ2lmeSIsIndlYmhvb2tfaGVhZGVycyIsIndlYmhvb2tfZGF0YV9zZWxlY3Rpb24iLCJ0b29scyIsInRvb2xfY2hvaWNlIiwiZGVwZW5kc19vbiIsInNvcnQiLCJ1c2VTdGVwRWRpdG9yIiwic3RlcCIsImluZGV4Iiwib25DaGFuZ2UiLCJsb2NhbFN0ZXAiLCJzZXRMb2NhbFN0ZXAiLCJ3ZWJob29rSGVhZGVycyIsInNldFdlYmhvb2tIZWFkZXJzIiwibGFzdFNlbnRTdGVwUmVmIiwiaXNJbnRlcm5hbFVwZGF0ZVJlZiIsImxvY2FsU3RlcFJlZiIsImN1cnJlbnQiLCJoYW5kbGVDaGFuZ2UiLCJmaWVsZCIsInZhbHVlIiwidXBkYXRlZCIsImhhbmRsZVdlYmhvb2tIZWFkZXJzQ2hhbmdlIiwiaGVhZGVycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/features/workflows/hooks/workflows-extra/useStepEditor.ts\n"));

/***/ })

});