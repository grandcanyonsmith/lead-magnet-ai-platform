"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/jobs/[...slug]/page",{

/***/ "(app-pages-browser)/./src/features/workflows/hooks/workflows-extra/useStepEditor.ts":
/*!***********************************************************************!*\
  !*** ./src/features/workflows/hooks/workflows-extra/useStepEditor.ts ***!
  \***********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStepEditor: function() { return /* binding */ useStepEditor; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// Helper to compare step objects by key fields\nfunction areStepsEqual(step1, step2) {\n    return step1.step_name === step2.step_name && step1.step_description === step2.step_description && step1.step_type === step2.step_type && step1.model === step2.model && step1.instructions === step2.instructions && step1.webhook_url === step2.webhook_url && JSON.stringify(step1.webhook_headers || {}) === JSON.stringify(step2.webhook_headers || {}) && JSON.stringify(step1.webhook_data_selection || {}) === JSON.stringify(step2.webhook_data_selection || {}) && JSON.stringify(step1.tools || []) === JSON.stringify(step2.tools || []) && step1.tool_choice === step2.tool_choice && JSON.stringify(step1.depends_on || []) === JSON.stringify(step2.depends_on || []);\n}\nfunction useStepEditor(param) {\n    let { step, index, onChange } = param;\n    const [localStep, setLocalStep] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(step);\n    const [webhookHeaders, setWebhookHeaders] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(step.webhook_headers || {});\n    const lastSentStepRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isInternalUpdateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Sync localStep when step prop changes (only if values actually changed)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Skip update if this change came from our own handleChange\n        if (isInternalUpdateRef.current) {\n            isInternalUpdateRef.current = false;\n            // Track what we just sent\n            lastSentStepRef.current = step;\n            return;\n        }\n        // Check if this is the step we just sent (parent echoing back our change)\n        if (lastSentStepRef.current && areStepsEqual(step, lastSentStepRef.current)) {\n            // This is our own update being echoed back - ignore it\n            return;\n        }\n        // Only update if the step actually changed (not just a new object reference)\n        if (!areStepsEqual(step, localStep)) {\n            setLocalStep(step);\n            // Sync webhook headers\n            if (step.webhook_headers) {\n                setWebhookHeaders(step.webhook_headers);\n            } else {\n                setWebhookHeaders({});\n            }\n        }\n    }, [\n        step\n    ]) // Only depend on step, not localStep to avoid loops\n    ;\n    const handleChange = (field, value)=>{\n        isInternalUpdateRef.current = true;\n        const updated = {\n            ...localStep,\n            [field]: value\n        };\n        setLocalStep(updated);\n        lastSentStepRef.current = updated;\n        onChange(index, updated);\n    };\n    const handleWebhookHeadersChange = (headers)=>{\n        setWebhookHeaders(headers);\n        handleChange(\"webhook_headers\", headers);\n    };\n    return {\n        localStep,\n        webhookHeaders,\n        handleChange,\n        handleWebhookHeadersChange\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9mZWF0dXJlcy93b3JrZmxvd3MvaG9va3Mvd29ya2Zsb3dzLWV4dHJhL3VzZVN0ZXBFZGl0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1EO0FBU25ELCtDQUErQztBQUMvQyxTQUFTRyxjQUFjQyxLQUFtQixFQUFFQyxLQUFtQjtJQUM3RCxPQUNFRCxNQUFNRSxTQUFTLEtBQUtELE1BQU1DLFNBQVMsSUFDbkNGLE1BQU1HLGdCQUFnQixLQUFLRixNQUFNRSxnQkFBZ0IsSUFDakRILE1BQU1JLFNBQVMsS0FBS0gsTUFBTUcsU0FBUyxJQUNuQ0osTUFBTUssS0FBSyxLQUFLSixNQUFNSSxLQUFLLElBQzNCTCxNQUFNTSxZQUFZLEtBQUtMLE1BQU1LLFlBQVksSUFDekNOLE1BQU1PLFdBQVcsS0FBS04sTUFBTU0sV0FBVyxJQUN2Q0MsS0FBS0MsU0FBUyxDQUFDVCxNQUFNVSxlQUFlLElBQUksQ0FBQyxPQUFPRixLQUFLQyxTQUFTLENBQUNSLE1BQU1TLGVBQWUsSUFBSSxDQUFDLE1BQ3pGRixLQUFLQyxTQUFTLENBQUNULE1BQU1XLHNCQUFzQixJQUFJLENBQUMsT0FBT0gsS0FBS0MsU0FBUyxDQUFDUixNQUFNVSxzQkFBc0IsSUFBSSxDQUFDLE1BQ3ZHSCxLQUFLQyxTQUFTLENBQUNULE1BQU1ZLEtBQUssSUFBSSxFQUFFLE1BQU1KLEtBQUtDLFNBQVMsQ0FBQ1IsTUFBTVcsS0FBSyxJQUFJLEVBQUUsS0FDdEVaLE1BQU1hLFdBQVcsS0FBS1osTUFBTVksV0FBVyxJQUN2Q0wsS0FBS0MsU0FBUyxDQUFDVCxNQUFNYyxVQUFVLElBQUksRUFBRSxNQUFNTixLQUFLQyxTQUFTLENBQUNSLE1BQU1hLFVBQVUsSUFBSSxFQUFFO0FBRXBGO0FBRU8sU0FBU0MsY0FBYyxLQUE2QztRQUE3QyxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsUUFBUSxFQUFzQixHQUE3QztJQUM1QixNQUFNLENBQUNDLFdBQVdDLGFBQWEsR0FBR3hCLCtDQUFRQSxDQUFlb0I7SUFDekQsTUFBTSxDQUFDSyxnQkFBZ0JDLGtCQUFrQixHQUFHMUIsK0NBQVFBLENBQ2xEb0IsS0FBS04sZUFBZSxJQUFJLENBQUM7SUFFM0IsTUFBTWEsa0JBQWtCekIsNkNBQU1BLENBQXNCO0lBQ3BELE1BQU0wQixzQkFBc0IxQiw2Q0FBTUEsQ0FBQztJQUVuQywwRUFBMEU7SUFDMUVELGdEQUFTQSxDQUFDO1FBQ1IsNERBQTREO1FBQzVELElBQUkyQixvQkFBb0JDLE9BQU8sRUFBRTtZQUMvQkQsb0JBQW9CQyxPQUFPLEdBQUc7WUFDOUIsMEJBQTBCO1lBQzFCRixnQkFBZ0JFLE9BQU8sR0FBR1Q7WUFDMUI7UUFDRjtRQUVBLDBFQUEwRTtRQUMxRSxJQUFJTyxnQkFBZ0JFLE9BQU8sSUFBSTFCLGNBQWNpQixNQUFNTyxnQkFBZ0JFLE9BQU8sR0FBRztZQUMzRSx1REFBdUQ7WUFDdkQ7UUFDRjtRQUVBLDZFQUE2RTtRQUM3RSxJQUFJLENBQUMxQixjQUFjaUIsTUFBTUcsWUFBWTtZQUNuQ0MsYUFBYUo7WUFDYix1QkFBdUI7WUFDdkIsSUFBSUEsS0FBS04sZUFBZSxFQUFFO2dCQUN4Qlksa0JBQWtCTixLQUFLTixlQUFlO1lBQ3hDLE9BQU87Z0JBQ0xZLGtCQUFrQixDQUFDO1lBQ3JCO1FBQ0Y7SUFDRixHQUFHO1FBQUNOO0tBQUssRUFBRSxvREFBb0Q7O0lBRS9ELE1BQU1VLGVBQWUsQ0FBQ0MsT0FBMkJDO1FBQy9DSixvQkFBb0JDLE9BQU8sR0FBRztRQUM5QixNQUFNSSxVQUFVO1lBQUUsR0FBR1YsU0FBUztZQUFFLENBQUNRLE1BQU0sRUFBRUM7UUFBTTtRQUMvQ1IsYUFBYVM7UUFDYk4sZ0JBQWdCRSxPQUFPLEdBQUdJO1FBQzFCWCxTQUFTRCxPQUFPWTtJQUNsQjtJQUVBLE1BQU1DLDZCQUE2QixDQUFDQztRQUNsQ1Qsa0JBQWtCUztRQUNsQkwsYUFBYSxtQkFBbUJLO0lBQ2xDO0lBRUEsT0FBTztRQUNMWjtRQUNBRTtRQUNBSztRQUNBSTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2ZlYXR1cmVzL3dvcmtmbG93cy9ob29rcy93b3JrZmxvd3MtZXh0cmEvdXNlU3RlcEVkaXRvci50cz8zYTNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgV29ya2Zsb3dTdGVwIH0gZnJvbSAnQC9mZWF0dXJlcy93b3JrZmxvd3MvdHlwZXMnXG5cbmludGVyZmFjZSBVc2VTdGVwRWRpdG9yUHJvcHMge1xuICBzdGVwOiBXb3JrZmxvd1N0ZXBcbiAgaW5kZXg6IG51bWJlclxuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHN0ZXA6IFdvcmtmbG93U3RlcCkgPT4gdm9pZFxufVxuXG4vLyBIZWxwZXIgdG8gY29tcGFyZSBzdGVwIG9iamVjdHMgYnkga2V5IGZpZWxkc1xuZnVuY3Rpb24gYXJlU3RlcHNFcXVhbChzdGVwMTogV29ya2Zsb3dTdGVwLCBzdGVwMjogV29ya2Zsb3dTdGVwKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgc3RlcDEuc3RlcF9uYW1lID09PSBzdGVwMi5zdGVwX25hbWUgJiZcbiAgICBzdGVwMS5zdGVwX2Rlc2NyaXB0aW9uID09PSBzdGVwMi5zdGVwX2Rlc2NyaXB0aW9uICYmXG4gICAgc3RlcDEuc3RlcF90eXBlID09PSBzdGVwMi5zdGVwX3R5cGUgJiZcbiAgICBzdGVwMS5tb2RlbCA9PT0gc3RlcDIubW9kZWwgJiZcbiAgICBzdGVwMS5pbnN0cnVjdGlvbnMgPT09IHN0ZXAyLmluc3RydWN0aW9ucyAmJlxuICAgIHN0ZXAxLndlYmhvb2tfdXJsID09PSBzdGVwMi53ZWJob29rX3VybCAmJlxuICAgIEpTT04uc3RyaW5naWZ5KHN0ZXAxLndlYmhvb2tfaGVhZGVycyB8fCB7fSkgPT09IEpTT04uc3RyaW5naWZ5KHN0ZXAyLndlYmhvb2tfaGVhZGVycyB8fCB7fSkgJiZcbiAgICBKU09OLnN0cmluZ2lmeShzdGVwMS53ZWJob29rX2RhdGFfc2VsZWN0aW9uIHx8IHt9KSA9PT0gSlNPTi5zdHJpbmdpZnkoc3RlcDIud2ViaG9va19kYXRhX3NlbGVjdGlvbiB8fCB7fSkgJiZcbiAgICBKU09OLnN0cmluZ2lmeShzdGVwMS50b29scyB8fCBbXSkgPT09IEpTT04uc3RyaW5naWZ5KHN0ZXAyLnRvb2xzIHx8IFtdKSAmJlxuICAgIHN0ZXAxLnRvb2xfY2hvaWNlID09PSBzdGVwMi50b29sX2Nob2ljZSAmJlxuICAgIEpTT04uc3RyaW5naWZ5KHN0ZXAxLmRlcGVuZHNfb24gfHwgW10pID09PSBKU09OLnN0cmluZ2lmeShzdGVwMi5kZXBlbmRzX29uIHx8IFtdKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGVwRWRpdG9yKHsgc3RlcCwgaW5kZXgsIG9uQ2hhbmdlIH06IFVzZVN0ZXBFZGl0b3JQcm9wcykge1xuICBjb25zdCBbbG9jYWxTdGVwLCBzZXRMb2NhbFN0ZXBdID0gdXNlU3RhdGU8V29ya2Zsb3dTdGVwPihzdGVwKVxuICBjb25zdCBbd2ViaG9va0hlYWRlcnMsIHNldFdlYmhvb2tIZWFkZXJzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+KFxuICAgIHN0ZXAud2ViaG9va19oZWFkZXJzIHx8IHt9XG4gIClcbiAgY29uc3QgbGFzdFNlbnRTdGVwUmVmID0gdXNlUmVmPFdvcmtmbG93U3RlcCB8IG51bGw+KG51bGwpXG4gIGNvbnN0IGlzSW50ZXJuYWxVcGRhdGVSZWYgPSB1c2VSZWYoZmFsc2UpXG5cbiAgLy8gU3luYyBsb2NhbFN0ZXAgd2hlbiBzdGVwIHByb3AgY2hhbmdlcyAob25seSBpZiB2YWx1ZXMgYWN0dWFsbHkgY2hhbmdlZClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTa2lwIHVwZGF0ZSBpZiB0aGlzIGNoYW5nZSBjYW1lIGZyb20gb3VyIG93biBoYW5kbGVDaGFuZ2VcbiAgICBpZiAoaXNJbnRlcm5hbFVwZGF0ZVJlZi5jdXJyZW50KSB7XG4gICAgICBpc0ludGVybmFsVXBkYXRlUmVmLmN1cnJlbnQgPSBmYWxzZVxuICAgICAgLy8gVHJhY2sgd2hhdCB3ZSBqdXN0IHNlbnRcbiAgICAgIGxhc3RTZW50U3RlcFJlZi5jdXJyZW50ID0gc3RlcFxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIHN0ZXAgd2UganVzdCBzZW50IChwYXJlbnQgZWNob2luZyBiYWNrIG91ciBjaGFuZ2UpXG4gICAgaWYgKGxhc3RTZW50U3RlcFJlZi5jdXJyZW50ICYmIGFyZVN0ZXBzRXF1YWwoc3RlcCwgbGFzdFNlbnRTdGVwUmVmLmN1cnJlbnQpKSB7XG4gICAgICAvLyBUaGlzIGlzIG91ciBvd24gdXBkYXRlIGJlaW5nIGVjaG9lZCBiYWNrIC0gaWdub3JlIGl0XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgXG4gICAgLy8gT25seSB1cGRhdGUgaWYgdGhlIHN0ZXAgYWN0dWFsbHkgY2hhbmdlZCAobm90IGp1c3QgYSBuZXcgb2JqZWN0IHJlZmVyZW5jZSlcbiAgICBpZiAoIWFyZVN0ZXBzRXF1YWwoc3RlcCwgbG9jYWxTdGVwKSkge1xuICAgICAgc2V0TG9jYWxTdGVwKHN0ZXApXG4gICAgICAvLyBTeW5jIHdlYmhvb2sgaGVhZGVyc1xuICAgICAgaWYgKHN0ZXAud2ViaG9va19oZWFkZXJzKSB7XG4gICAgICAgIHNldFdlYmhvb2tIZWFkZXJzKHN0ZXAud2ViaG9va19oZWFkZXJzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0V2ViaG9va0hlYWRlcnMoe30pXG4gICAgICB9XG4gICAgfVxuICB9LCBbc3RlcF0pIC8vIE9ubHkgZGVwZW5kIG9uIHN0ZXAsIG5vdCBsb2NhbFN0ZXAgdG8gYXZvaWQgbG9vcHNcblxuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSAoZmllbGQ6IGtleW9mIFdvcmtmbG93U3RlcCwgdmFsdWU6IGFueSkgPT4ge1xuICAgIGlzSW50ZXJuYWxVcGRhdGVSZWYuY3VycmVudCA9IHRydWVcbiAgICBjb25zdCB1cGRhdGVkID0geyAuLi5sb2NhbFN0ZXAsIFtmaWVsZF06IHZhbHVlIH1cbiAgICBzZXRMb2NhbFN0ZXAodXBkYXRlZClcbiAgICBsYXN0U2VudFN0ZXBSZWYuY3VycmVudCA9IHVwZGF0ZWRcbiAgICBvbkNoYW5nZShpbmRleCwgdXBkYXRlZClcbiAgfVxuXG4gIGNvbnN0IGhhbmRsZVdlYmhvb2tIZWFkZXJzQ2hhbmdlID0gKGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pID0+IHtcbiAgICBzZXRXZWJob29rSGVhZGVycyhoZWFkZXJzKVxuICAgIGhhbmRsZUNoYW5nZSgnd2ViaG9va19oZWFkZXJzJywgaGVhZGVycylcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbG9jYWxTdGVwLFxuICAgIHdlYmhvb2tIZWFkZXJzLFxuICAgIGhhbmRsZUNoYW5nZSxcbiAgICBoYW5kbGVXZWJob29rSGVhZGVyc0NoYW5nZSxcbiAgfVxufVxuXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJhcmVTdGVwc0VxdWFsIiwic3RlcDEiLCJzdGVwMiIsInN0ZXBfbmFtZSIsInN0ZXBfZGVzY3JpcHRpb24iLCJzdGVwX3R5cGUiLCJtb2RlbCIsImluc3RydWN0aW9ucyIsIndlYmhvb2tfdXJsIiwiSlNPTiIsInN0cmluZ2lmeSIsIndlYmhvb2tfaGVhZGVycyIsIndlYmhvb2tfZGF0YV9zZWxlY3Rpb24iLCJ0b29scyIsInRvb2xfY2hvaWNlIiwiZGVwZW5kc19vbiIsInVzZVN0ZXBFZGl0b3IiLCJzdGVwIiwiaW5kZXgiLCJvbkNoYW5nZSIsImxvY2FsU3RlcCIsInNldExvY2FsU3RlcCIsIndlYmhvb2tIZWFkZXJzIiwic2V0V2ViaG9va0hlYWRlcnMiLCJsYXN0U2VudFN0ZXBSZWYiLCJpc0ludGVybmFsVXBkYXRlUmVmIiwiY3VycmVudCIsImhhbmRsZUNoYW5nZSIsImZpZWxkIiwidmFsdWUiLCJ1cGRhdGVkIiwiaGFuZGxlV2ViaG9va0hlYWRlcnNDaGFuZ2UiLCJoZWFkZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/features/workflows/hooks/workflows-extra/useStepEditor.ts\n"));

/***/ })

});